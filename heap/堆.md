#堆
使用完全二叉树来实现，因为完全二叉树可以由数组来实现，因此堆也可以使用数组来实现。
如果数组中的一个元素的下标为 $i$ ，那么他的
1. 父节点对应的下标为 $（i-1）/ 2 $,
2. 左子节点下标为 $2i+1$
3. 右子节点下表为 $2i+2$
插入节点操作为：将新插入的节点放在最下层最右边的位置，即满足满二叉树的唯一的位置。然后再对节完全二叉树进行节点调整，上浮或者下层操作。直到所有的节点都满足：
节点值大于等于儿子节点的值为止。
## 大顶堆
堆顶的节点值最大

用来解决K个元素的<font color = "red" size = 5>最小元素</font>

## 小顶堆
堆顶的节点值最小

用来解决K个元素的<font color = "red" size = 5>最大元素</font>。

以上的解决问题刚好是和数据结构刚好相反。
## 应用
对最大的特点就是最大值或者最小值位于堆顶位置，所以只需要 $O(1)$ 的时间复杂度就可以得到数组中的最值，并且其插入或删除的时间复杂度为 $O(log_n)$.

###top K 问题
[剑指 Offer II 059. 数据流的第 K 大数值](file///../mainshiti_59.cpp)
使用小顶堆来解决动态数组中的第  K  大数值。

[剑指 Offer II 060. 出现频率最高的 k 个数字](file///../mianshiti_60.cpp)
对于出现的数使用一个数组对进行存储 [数值, 频率]
然后将数值对按照出现的频率存储在小根堆中，类似 59 题。
[剑指 Offer II 061. 和最小的 k 个数对](file///../mianshiti_61.cpp)

相当于对两个数组使用一个二维数组来进行计算

|   |nums1| 1|7 |11 | 
|---|---|---|---|---|
|nums2|| | | | 
|2||3 |7 | 13| 
|4||5 |11 |15 | 
|6|| 7| 13|17 | 

使用的方法是：
1. 先将<font color = red>第一行(第一列)</font>的下标存储在小根堆中，最小元素肯定是其实位置
2. 然后取出来的最小和组合后，就可以<font color = red>往下（右）</font >继续添加下标位置
3. 持续循环执行步骤 2 就可以得到答案。